# -*- coding: utf-8 -*-
"""AI-Q-Learning-vacuum-robot-v3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G8ASRXYmREtD6eY31yuYVnyurXxyrV6t

Biblioteca
"""

!pip install numpy matplotlib imageio

"""Ambiente: planta baixa e as posições de sujeira.

Configuração do ambiente
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import random

# Configuração da planta baixa
grid_size = (10, 10)
house = np.zeros(grid_size)
dirt_positions = [(2, 3), (5, 5), (8, 8)]
for dirt in dirt_positions:
    house[dirt] = 1  # 1 representa sujeira

# Paredes como obstáculos
walls = [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1)]
for wall in walls:
    house[wall] = -1  # -1 representa uma parede

# Função para visualizar a configuração inicial
def draw_initial_grid(house):
    fig, ax = plt.subplots()
    block_size = 1
    for x in range(grid_size[0]):
        for y in range(grid_size[1]):
            if house[x, y] == 1:
                rect = patches.Rectangle((y, x), block_size, block_size, linewidth=1, edgecolor='black', facecolor='green')
            elif house[x, y] == -1:
                rect = patches.Rectangle((y, x), block_size, block_size, linewidth=1, edgecolor='black', facecolor='red')
            else:
                rect = patches.Rectangle((y, x), block_size, block_size, linewidth=1, edgecolor='black', facecolor='white')
            ax.add_patch(rect)
    ax.set_xlim(0, grid_size[1])
    ax.set_ylim(0, grid_size[0])
    ax.set_aspect('equal')
    plt.gca().invert_yaxis()
    plt.title('Initial Configuration')
    plt.legend(handles=[
        patches.Patch(color='green', label='Dirt'),
        patches.Patch(color='red', label='Wall'),
        patches.Patch(color='white', label='Empty')
    ], bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.show()

# Visualizando a configuração inicial
draw_initial_grid(house)

"""Aprendizado por reforço: Q-learning para treinar o robô aspirador.

Treinamento do robo aspirador: arrumar...convergindo muito rapido

Certificação de Posição Inicial: Garantimos que o robô não comece em uma posição de sujeira ou parede.
Limpeza da Sujeira: Após encontrar sujeira, o robô a limpa, atualizando a posição para 0

Reduzir a Taxa de Decaimento do Epsilon: Isso vai permitir que o robô explore por mais tempo antes de começar a explorar menos.
Reiniciar o Estado da Casa Periodicamente: Para garantir que a sujeira reapareça e o robô tenha novas oportunidades de aprender.
Verificar se o Robô Não Está Preso: Adicionar um mecanismo para garantir que o robô não está preso em um ciclo de estados inválidos.

Decaimento do Epsilon: A taxa de decaimento foi reduzida para 0.999, o que permitirá mais exploração.
Reinicialização do Estado da Casa: A casa é reiniciada a cada episódio para garantir que a sujeira esteja presente em cada novo episódio

Aumentar a taxa de aprendizado: Ajuste o alpha para 0.2 para ver se ele ajuda a aprender mais rapidamente.
Aumentar o fator de desconto: Ajuste o gamma para 0.95 para dar mais valor a recompensas futuras.
Adicionar mais aleatoriedade na escolha do estado inicial: Isso pode ajudar a variar mais as experiências de treinamento.

Reduzir a recompensa ao encontrar sujeira: Reduzir a recompensa direta pode fazer o robô se esforçar mais para aprender outras partes do ambiente.

Adicionar penalidades por movimento: Adicionar uma pequena penalidade por cada movimento pode incentivar o robô a encontrar sujeira de forma mais eficiente.

Aumentar a variação dos estados iniciais: Começar de uma maior variedade de posições iniciais pode ajudar o robô a explorar mais o ambiente.

Caso queira fazer mais ajustes ou explorar outras possibilidades, algumas sugestões poderiam incluir:

Alterar a taxa de aprendizado (alpha): Se você perceber que o robô está convergindo muito lentamente ou muito rapidamente, ajustar a taxa de aprendizado pode ajudar.

Adicionar mais sujeira ou obstáculos: Adicionar mais elementos no ambiente pode tornar o problema mais desafiador e interessante para o robô.

Testar diferentes políticas de exploração-exploração (epsilon): Experimente diferentes estratégias de decaimento de epsilon para encontrar um bom equilíbrio entre exploração e exploração.

Aumentar o número de episódios: Em alguns casos, treinar por mais episódios pode ajudar a melhorar ainda mais o desempenho do robô.
"""

import time
import imageio

# Inicializando a Q-Table
q_table = np.zeros((grid_size[0], grid_size[1], 4))  # 4 ações: cima, baixo, esquerda, direita

# Hiperparâmetros
alpha = 0.2  # Taxa de aprendizado
gamma = 0.95  # Fator de desconto
epsilon = 1.0  # Taxa de exploração inicial
epsilon_decay = 0.995  # Taxa de decaimento da exploração ajustada
epsilon_min = 0.1  # Taxa mínima de exploração
max_steps_per_episode = 100  # Limite de passos por episódio
move_penalty = -0.1  # Penalidade por cada movimento

# Funções auxiliares
def choose_action(state):
    if random.uniform(0, 1) < epsilon:
        action = random.randint(0, 3)  # Explorar
    else:
        action = np.argmax(q_table[state[0], state[1]])  # Exploitar
    return action

def get_next_state(state, action):
    if action == 0:  # cima
        next_state = (max(state[0] - 1, 0), state[1])
    elif action == 1:  # baixo
        next_state = (min(state[0] + 1, grid_size[0] - 1), state[1])
    elif action == 2:  # esquerda
        next_state = (state[0], max(state[1] - 1, 0))
    else:  # direita
        next_state = (state[0], min(state[1] + 1, grid_size[1] - 1))
    return next_state

def is_valid_state(state):
    return house[state] != -1

# Função para reiniciar o estado da casa
def reset_house():
    house.fill(0)
    for dirt in dirt_positions:
        house[dirt] = 1
    for wall in walls:
        house[wall] = -1

# Treinando o robô
rewards_per_episode = []
for episode in range(1000):
    reset_house()  # Reinicia o estado da casa a cada episódio
    state = (random.randint(0, grid_size[0] - 1), random.randint(0, grid_size[1] - 1))
    while not is_valid_state(state) or house[state] == 1:  # Certificando-se de que não começamos em uma parede ou sujeira
        state = (random.randint(0, grid_size[0] - 1), random.randint(0, grid_size[1] - 1))

    steps = 0
    total_reward = 0
    while steps < max_steps_per_episode:
        action = choose_action(state)
        next_state = get_next_state(state, action)
        if is_valid_state(next_state):
            reward = house[next_state]
            q_table[state[0], state[1], action] = q_table[state[0], state[1], action] + \
                alpha * (reward + gamma * np.max(q_table[next_state[0], next_state[1]]) - q_table[state[0], state[1], action])
            state = next_state
            total_reward += reward + move_penalty
            if reward == 1:
                house[next_state] = 0  # Limpar a sujeira
                print(f"Episódio {episode}, Passo {steps}: Robô encontrou sujeira na posição {state}!")
                break
        steps += 1

    rewards_per_episode.append(total_reward)
    epsilon = max(epsilon_min, epsilon * epsilon_decay)
    if episode % 100 == 0:
        print(f"Episódio {episode} concluído com recompensa total: {total_reward}")

print("Treinamento concluído!")

# Plotando as recompensas por episódio
plt.plot(rewards_per_episode)
plt.xlabel('Episódio')
plt.ylabel('Recompensa Total')
plt.title('Recompensa Total por Episódio durante o Treinamento')
plt.show()

"""Simulacao e salvamento

Simulacao com metrica
"""

import imageio
import time
import os
import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Função para desenhar a grid e o estado atual do robô
def draw_grid(house, state, iteration):
    fig, ax = plt.subplots()
    block_size = 1
    for x in range(grid_size[0]):
        for y in range(grid_size[1]):
            if house[x, y] == 1:
                rect = patches.Rectangle((y, x), block_size, block_size, linewidth=1, edgecolor='black', facecolor='green')
            elif house[x, y] == -1:
                rect = patches.Rectangle((y, x), block_size, block_size, linewidth=1, edgecolor='black', facecolor='red')
            else:
                rect = patches.Rectangle((y, x), block_size, block_size, linewidth=1, edgecolor='black', facecolor='white')
            ax.add_patch(rect)
    # Desenhando o robô
    robot = patches.Circle((state[1] + 0.5, state[0] + 0.5), 0.3, linewidth=1, edgecolor='blue', facecolor='blue')
    ax.add_patch(robot)
    ax.set_xlim(0, grid_size[1])
    ax.set_ylim(0, grid_size[0])
    ax.set_aspect('equal')
    plt.gca().invert_yaxis()
    plt.title(f'Iteration: {iteration}')
    legend_handles = [
        patches.Patch(color='green', label='Dirt'),
        patches.Patch(color='red', label='Wall'),
        patches.Patch(color='white', label='Empty'),
        patches.Patch(color='blue', label='Vacuum')
    ]
    ax.legend(handles=legend_handles, bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.savefig(f'iteration_{iteration}.png')
    plt.show()
    plt.close()

# Simulação e criação do GIF
filenames = []
reset_house()
state = (0, 0)

dirt_cleaned = 0
total_iterations = 50
start_time = time.time()

for iteration in range(total_iterations):  # Simular por 50 iterações
    action = choose_action(state)
    next_state = get_next_state(state, action)
    if is_valid_state(next_state):
        state = next_state
    # Se o robô encontrar sujeira, limpa a sujeira
    if house[state[0], state[1]] == 1:
        house[state[0], state[1]] = 0  # Marca como limpo
        dirt_cleaned += 1
    draw_grid(house, state, iteration)
    filenames.append(f'iteration_{iteration}.png')
    time.sleep(0.1)

end_time = time.time()
total_time = end_time - start_time

# Criando o GIF
images = []
for filename in filenames:
    images.append(imageio.imread(filename))
imageio.mimsave('simulation.gif', images, duration=0.5)

# Remover arquivos PNG temporários
for filename in filenames:
    os.remove(filename)

# Exibir métricas da simulação
print(f'Total de sujeiras limpas: {dirt_cleaned}')
print(f'Tempo total de simulação: {total_time:.2f} segundos')
print(f'Média de sujeiras limpas por iteração: {dirt_cleaned / total_iterations:.2f}')

# Exibir o GIF criado
from IPython.display import Image, display
display(Image(filename='simulation.gif'))